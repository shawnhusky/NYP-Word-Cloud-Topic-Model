from azure.storage.blob import BlockBlobService
import pandas as pd
import time
import dash
import dash_core_components as dcc
import dash_html_components as html
import plotly.express as px
import pandas as pd
import numpy as np
import plotly
import plotly.graph_objs as go
from plotly.offline import plot
import random
import math
import re

from dash.dependencies import Input, Output

from app import app

"""
#declare vars for blob storage

STORAGEACCOUNTNAME3= "bla"
STORAGEACCOUNTKEY3= "bla"
LOCALFILENAME3= "bla"
CONTAINERNAME3= "bla"
BLOBNAME3= "bla"


#stream

block_blob_service3 = BlockBlobService(account_name=STORAGEACCOUNTNAME3, account_key=STORAGEACCOUNTKEY3)

from io import BytesIO
import pandas as pd
with BytesIO() as input_blob3:
    block_blob_service3.get_blob_to_stream(CONTAINERNAME3, BLOBNAME3, input_blob3)
    input_blob3.seek(0)
    df3 = pd.read_csv(input_blob3)   

"""
input_blob3= "samplesentsaspect.csv"
df3 = pd.read_csv(input_blob3)  
#print(df3)
#ALl sentences in a list--------------------------------------
aspect_sentences_list = []

#loop through dataframe3 dataframe 3 is for app3. dataframe 2 is for app2.Whatever written here is just for app3.
#Not pulling from other apps.

for i in range(len(df3.index)):
        
       

        #filter unwanted chars
        df3['sentences'][i] = df3['sentences'][i].replace(r"http\S+", "")
        df3['sentences'][i] = df3['sentences'][i].replace(r"http", "")
        df3['sentences'][i] = df3['sentences'][i].replace(r"@\S+", "")
        df3['sentences'][i] = df3['sentences'][i].replace(r"[^A-Za-z0-9(),!?@\'\`\"\_\n]", " ")
        df3['sentences'][i]  = df3['sentences'][i].replace(r"@", "at")
        df3['sentences'][i]  = df3['sentences'][i].lower()

         #replace[]
        df3['sentences'][i] = df3['sentences'][i].replace('[',"")
        df3['sentences'][i] = df3['sentences'][i].replace(']',"")

        #replace()
        df3['sentences'][i] = df3['sentences'][i].replace('(',"")
        df3['sentences'][i] = df3['sentences'][i].replace(')',"")

        #replace" and '
        df3['sentences'][i] = df3['sentences'][i].replace("'","")
        df3['sentences'][i] = df3['sentences'][i].replace('"',"")

        #replace.
        df3['sentences'][i] = df3['sentences'][i].replace(".","")
        
        aspect_sentences = df3['sentences'][i]
        #put in list
        aspect_sentences1 = aspect_sentences.split(',')
        aspect_sentences_list.append(aspect_sentences1)

        #print(aspect_sentences_list)


#make list flat again if not 2D very annoying. Non nested. Easier to work with
aspect_sentences_list_flat = [item for sublist in aspect_sentences_list for item in sublist]

#some test code
#print("flat list")
#print(str(aspect_sentences_list_flat[0]))
#result = df3['aspect_impt'].where(df3['sentences'] == str())
#print("searching")
#result = df3[df3['sentences'].str.contains(str(aspect_sentences_list_flat[1]))]
#print(result['aspect_impt'])
#aspect_impt_float = re.findall("\d+\.\d+", str(result['aspect_impt']))
#print(aspect_impt_float) #all 5 topics in a list


# get tensor flow weightage-------------------------------
aspect_impt = df3['aspect_impt']

#print(str(aspect_impt))
#get float values of tensor flow

#use re to search weightages then put in list.
#i always use list
#if i use any conversions is because of error from compiler

import re
aspect_impt_float = re.findall("\d+\.\d+", str(aspect_impt))
#print("float vlaues")
#print(aspect_impt_float)

#convert to float for topic1,2,3,4
import numpy as np
aspect_impt_float = list(np.float_(aspect_impt_float))

#before you can make entire list you have to make it so that it is in sync
#take topic 1 to 5 and decide how many times u want to put in another list

#notice here topic 5 declared but i never show in the front end later.
#you can always add it and find ways to dynamic it.Because topic 5 in csv file was generated by machine learning.
#so it might generate topic 6,7.. try to make this part dynamic
#entire list
#print(aspect_impt_float)
aspect_impt_float_topic1 = []
aspect_impt_float_topic2 = []
aspect_impt_float_topic3 = []
aspect_impt_float_topic4 = []
aspect_impt_float_topic5 = []
"""
aspect_impt_float_topic1.append(aspect_impt_float[0])
aspect_impt_float_topic2.append(aspect_impt_float[1])
aspect_impt_float_topic3.append(aspect_impt_float[2])
aspect_impt_float_topic4.append(aspect_impt_float[3])
"""

#print('topic2')
#print(aspect_impt_float_topic2)

#find out no. of sentences
no_of_sentencesApp3 = len(aspect_sentences_list_flat)
#print("no of sentence")
#print(no_of_sentencesApp3)

layout = html.Div([
    html.H1(children='Sentences and Topics'),

    html.Div([
dcc.Dropdown(
    id="variable_choice_app3",
    options=[{"label": i*6, "value": i*6} for i in range(int(no_of_sentencesApp3/6))],value=6 #no of sentence/6
    )
    ], style={"width": "50%", "display" : "block"}),

    html.Div(id='sentenceapp3')

])



@app.callback(
    Output('sentenceapp3', 'children'),
    Input("variable_choice_app3", "value"))

def update_graph_app3(variable_choice_app3):



     #fixed x error on dropdown
        if variable_choice_app3 == None:
            variable_choice_app3 = 1

        #append before return since cant iterate any where!
        #old list has items already put in new list then throw to return

        FinalTableReturnApp3 = [] #new list


        k = 0

        
        #search dataframe to find 
        #k is like i for iteration. start with 0 then for loop until max elements of aspect_sentences_list_flat
        #for every element in df3['sentences'] you are checking if contains aspect_sentence
        #aspect_impt_float is where you get the result you wanted to find then append it to
        #indvidual topic1,2,3,4,5, lists.
        #these list will later be pulled from and attach to the sentence to be displayed for that particular row 
        #max_rows = the rows requested
        #if got error just except then print no data

        #see csv file to know why i have to make it like this
        def generate_html_table_App3(max_rows=5):
        
            #haven deal with not found problem and if more than one row
            
            for k in range(min(len(aspect_sentences_list_flat), max_rows)):

                    try:
                        aspect_sentence = str(aspect_sentences_list_flat[k])#if got problem , k + 1 to skip over the 1st row error cos no output or dont exist 
                    
                    
                

                        result = df3[df3['sentences'].str.contains(aspect_sentence)]
                        print('impt')
                        print(result['aspect_impt'])

                        aspect_impt_float = re.findall("\d+\.\d+", str(result['aspect_impt']))
                        print('shawnnn')
                        #print(aspect_impt_float[0]) #all 5 topics in a list
                        #print(i)
                        aspect_impt_float_topic1.append(aspect_impt_float[0])
                        aspect_impt_float_topic2.append(aspect_impt_float[1])
                        aspect_impt_float_topic3.append(aspect_impt_float[2])
                        aspect_impt_float_topic4.append(aspect_impt_float[3])
                        aspect_impt_float_topic5.append(aspect_impt_float[4])

                    except:
                        aspect_sentence = 'no data'
            
                    FinalTableReturnApp3.append(html.Tr([
                    html.Td(html.A([
                    #append text to show
                    aspect_sentences_list_flat[k]

                

                    #result = df3['aspect_impt'].where(df3['sentences'] == str())
                    #print("searching")


                    



                    ], id=str(k)))
                ]))

        print('global')
        print(aspect_impt_float_topic5)

        #all the rest of the generate functions are for pulling topic 12345 weightages respectively and appending it
        #to finaltablereturnapp3 list.
        
        #you can append entire html to list. Its fine.

        FinalTableReturn2App3 = [] #new list
        
        def generate_html_table2_App3(max_rows=5):

            for i in range(min(len(aspect_impt_float_topic1), max_rows)):
                
                #check if 4th element then append new row
                FinalTableReturn2App3.append(html.Tr([
                    html.Td(html.A([
                    #append text to show
                    aspect_impt_float_topic1[i]
                    ], id=str(i)))
                ]))

        FinalTableReturn3App3 = [] #new list
        
        def generate_html_table3_App3(max_rows=5):

            for i in range(min(len(aspect_impt_float_topic2), max_rows)):
                
                #check if 4th element then append new row
                FinalTableReturn3App3.append(html.Tr([
                    html.Td(html.A([
                    #append text to show
                    aspect_impt_float_topic2[i]
                    ], id=str(i)))
                ]))

        FinalTableReturn4App3 = [] #new list
        
        def generate_html_table4_App3(max_rows=5):

            for i in range(min(len(aspect_impt_float_topic3), max_rows)):
                
                #check if 4th element then append new row
                FinalTableReturn4App3.append(html.Tr([
                    html.Td(html.A([
                    #append text to show
                    aspect_impt_float_topic3[i]
                    ], id=str(i)))
                ]))

        FinalTableReturn5App3 = [] #new list
        
        def generate_html_table5_App3(max_rows=5):

            for i in range(min(len(aspect_impt_float_topic4), max_rows)):
                
                #check if 4th element then append new row
                FinalTableReturn5App3.append(html.Tr([
                    html.Td(html.A([
                    #append text to show
                    aspect_impt_float_topic4[i]
                    ], id=str(i)))
                ]))

        

        #+1 because array start from 0 and user selection always start from 0
        #update return stop here
        #throwing user selection + 1 to generate html table function
        #so next section the vars will be updated

        generate_html_table_App3(variable_choice_app3+1)
        generate_html_table2_App3(variable_choice_app3+1)
        generate_html_table3_App3(variable_choice_app3+1)
        generate_html_table4_App3(variable_choice_app3+1)
        generate_html_table5_App3(variable_choice_app3+1)
        
        #compile final rows here
       

            
        #display 6, loop 6 times put in div
        #variable_choice_app3-1 beacause array starts from 0
        row = []
        #column
        row.append(html.Tr([html.Th("App3 Sentences"),html.Th("Topic1"),html.Th("Topic2"),html.Th("Topic3"),html.Th("Topic4")]),
        )
        for i in range(variable_choice_app3):
            row.append(html.Tr([html.Td(FinalTableReturnApp3[i]),html.Td(FinalTableReturn2App3[i]),html.Td(FinalTableReturn3App3[i]),html.Td(FinalTableReturn4App3[i]),html.Td(FinalTableReturn5App3[i])]))
            
            

        #return everything encapsulate as html div then throw to layout
        return html.Div([
            html.Div(children=html.Table(
             [

                html.Tr(row)#row
                 
             ]
         ), id='fixedheight',style={"width": "50%", "display" : "inline-flex"})

            


        
        ])